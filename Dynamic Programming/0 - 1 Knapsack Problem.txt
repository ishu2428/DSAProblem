0 - 1 Knapsack Problem

Given n items, each with a specific weight and value, and a knapsack with a capacity of W, the task is to put the items in the knapsack such that the sum of weights of the items <= W and the sum of values associated with them is maximized. 

Note: You can either place an item entirely in the bag or leave it out entirely. Also, each item is available in single quantity.

Examples :

Input: W = 4, val[] = [1, 2, 3], wt[] = [4, 5, 1] 
Output: 3
Explanation: Choose the last item, which weighs 1 unit and has a value of 3.
Input: W = 3, val[] = [1, 2, 3], wt[] = [4, 5, 6] 
Output: 0
Explanation: Every item has a weight exceeding the knapsack's capacity (3).
Input: W = 5, val[] = [10, 40, 30, 50], wt[] = [5, 4, 2, 3] 
Output: 80
Explanation: Choose the third item (value 30, weight 2) and the last item (value 50, weight 3) for a total value of 80.

Code:----------------------------

class Solution {
    static int knapsack(int W, int val[], int wt[]) 
    {
        int dp[][]=new int[val.length+1][W+1];
        for(int i=0;i<dp.length;i++)
        {
            for(int j=0;j<dp[0].length;j++)
            {
                dp[i][j]=-1;
            }
        }
        return solve(W,val,wt,0,dp);
    }
    public static int solve(int W,int val[],int wt[],int ind,int dp[][])
    {
        if(W<=0)
        {
            return 0;
        }
        if(ind>=val.length)
        {
            return 0;
        }
        
        if(dp[ind][W]!=-1)
        {
            return dp[ind][W];
        }
        if(W>=wt[ind])
        {
            int ans1=val[ind]+solve(W-wt[ind],val,wt,ind+1,dp);
            int ans2=solve(W,val,wt,ind+1,dp);
            dp[ind][W]=Math.max(ans1,ans2);
            return dp[ind][W];
        }
        else
        {
            dp[ind][W]=solve(W,val,wt,ind+1,dp);
            return dp[ind][W];
        }
    }
}
